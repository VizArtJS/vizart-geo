<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=default"></script>
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="lib/crossfilter.js"></script>
    <script src="lib/chroma.js"></script>
    <script src="lib/viewport.js"></script>
    <script src="https://cdn.jsdelivr.net/lodash/4.17.4/lodash.min.js"></script>
    <script src="lib/d3-ForceEdgeBundling.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.38.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.38.0/mapbox-gl.css' rel='stylesheet' />
</head>
<body>

<style>
    #menu {
        position: absolute;
        background: #fff;
        padding: 10px;
        font-family: 'Open Sans', sans-serif;
    }

    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    #map {
        position:absolute;
        width: 100%;
        height: 100%;
    }
    canvas {
        position: absolute;
        width: 100%;
        height: 100%;
    }


</style>

<div id='map'></div>
<div id='menu'>
    <input id='basic' type='radio' name='rtoggle' value='basic' checked='checked'>
    <label for='basic'>basic</label>
    <input id='streets' type='radio' name='rtoggle' value='streets'>
    <label for='streets'>streets</label>
    <input id='bright' type='radio' name='rtoggle' value='bright'>
    <label for='bright'>bright</label>
    <input id='light' type='radio' name='rtoggle' value='light'>
    <label for='light'>light</label>
    <input id='dark' type='radio' name='rtoggle' value='dark'>
    <label for='dark'>dark</label>
    <input id='satellite' type='radio' name='rtoggle' value='satellite'>
    <label for='satellite'>satellite</label>
</div>

<script>
    $(function () {
        mapboxgl.accessToken = 'pk.eyJ1IjoiYmlnZmF0ZG9nIiwiYSI6ImM1ZWIyYzYzMzkyM2JlMTc0M2VjNmRlOTk5NDdkN2VjIn0.DoyA-reichUjF_FO9dkazQ';
        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v9',
            zoom: 4,
            pitch: 40,
            minZoom: 3,
            maxZoom: 18,
            center: [-74.0059, 40.7128],
        });

        var bundlingWorker = new Worker("worker.js");
        var forceWorker = new Worker("worker2.js");

        //map.scrollZoom.disable()
        map.addControl(new mapboxgl.NavigationControl());

        var layerList = document.getElementById('menu');
        var inputs = layerList.getElementsByTagName('input');

        function switchLayer(layer) {
            var layerId = layer.target.id;
            map.setStyle('mapbox://styles/mapbox/' + layerId + '-v9');
        }

        for (var i = 0; i < inputs.length; i++) {
            inputs[i].onclick = switchLayer;
        }
        // Setup our svg layer that we can manipulate with d3
        var container = map.getCanvasContainer();
        var bbox = document.body.getBoundingClientRect();
        var width = bbox.width;
        var height = bbox.height;
        let devicePixelRatio = window.devicePixelRatio || 1;
        var _canvas = d3.select(container)
            .append("canvas")
            .attr('id', 'force-overlay')
            .style("width", width + "px")
            .style("height", height + "px")
            .attr("width", width * devicePixelRatio)
            .attr("height", height * devicePixelRatio);
        var _context = _canvas.node().getContext("2d");
        _context.scale(devicePixelRatio, devicePixelRatio);


        function asLine(d) {
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
        }

        // we can project a lonlat coordinate pair using mapbox's built in projection function
        function mapboxProjection(lonlat) {
            var p = map.project(new mapboxgl.LngLat(lonlat[0], lonlat[1]))
            return [p.x, p.y];
        }

        function projectStream(lon, lat) {
//            var point = map.project(new mapboxgl.LngLat(lon, lat));
//            this.stream.point(point.x, point.y);
            this.stream.point(lon, lat);
        }

        // we can use viewport-mercator-project to get projection and unprojection functions
        function getVP() {
            var bbox = document.body.getBoundingClientRect();
            var center = map.getCenter();
            var zoom = map.getZoom();
            var vp = ViewportMercator({
                longitude: center.lng,
                latitude: center.lat,
                zoom: zoom,
                width: bbox.width,
                height: bbox.height,
            })
            return vp;
        }


        // we calculate the scale given mapbox state (derived from viewport-mercator-project's code)
        // to define a d3 projection
        function getD3() {
            var bbox = document.body.getBoundingClientRect();
            var center = map.getCenter();
            var zoom = map.getZoom();
            // 512 is hardcoded tile size, might need to be 256 or changed to suit your map config
            var scale = (512) * 0.5 / PI * pow(2, zoom);

            var d3projection = d3.geoMercator()
                .center([center.lng, center.lat])
                .translate([bbox.width/2, bbox.height/2])
                .scale(scale);

            return d3projection;
        }


        // calculate the original viewport-mercator-project projection
        var vp = getVP();

        // calculate the original d3 projection
        var d3Projection = getD3()

//        // we want to render the same point
//        var point = [-74.0059, 40.7128]
//
//        var mapboxCircle = _canvas.append("circle").classed("mapbox", true)
//        var vpCircle = _canvas.append("circle").classed("vp", true)
//        var d3Circle = _canvas.append("circle").classed("d3", true)

        // you can use any of these projections to create a d3.geo.path
        // function for rendering lines and polygons
        var transform = d3.geoTransform({point: projectStream});
        var path = d3.geoPath().projection(transform).context(_context);
//         var path = d3.geo.path().projection(d3Projection)

        var points;
        var eedges = [];
        var nnodes = {};
        var _data = [];

        function drawPoints() {
            _data = _.values(nnodes);
            _context.clearRect(0, 0, width, height);
            _context.fillStyle ='#7dde4f';
            _context.beginPath();
            for (let d of _data) {
                _context.moveTo(d.x, d.y);
                _context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
            }

            _context.fill();
        }


        var d3line = d3.line()
            .x(function (d) {
                return d.x;
            })
            .y(function (d) {
                return d.y;
            })
            .curve(d3.curveCatmullRom.alpha(0.5))
            .context(_context);

        map.on('load', function() {

            d3.xml("assets/airlines.xml", function (xml) {
                //Transform the XML data into a proper format used by the algorithm
                var raw_edges = xml.documentElement.getElementsByTagName("edge");
                var raw_nodes = xml.documentElement.getElementsByTagName("node");


                for (var i = 0; i < raw_nodes.length; i++) {
                    var key = raw_nodes[i].getAttribute('id');

                    var name = raw_nodes[i].childNodes[3].firstChild.nodeValue;

                    var name2 = name.substring(name.indexOf('(') + 1, name.indexOf(')'));
                    let arr = name2.split(',')
                    let lon = arr[0].substring(5, name.length -1);
                    let lat = arr[1].substring(5, name.length -1);

                    let p_ = [lon, lat];
                    let proj = mapboxProjection(p_);
                    nnodes[key] = {
                        id: key,
                        latitude: lat,
                        longitude: lon,
                        x: proj[0],
                        y:  proj[1],
                    };
                }

                for (var i = 0; i < raw_edges.length; i++) {
                    eedges.push({
                        id: i,
                        'source': raw_edges[i].getAttribute('source'),
                        'target': raw_edges[i].getAttribute('target')
                    });
                }

                drawPoints();
                drawLinks();
            });

        });


        function forceLinks() {
            forceWorker.terminate();
            forceWorker = new Worker('worker2.js');

            forceWorker.postMessage({
                nodes: nnodes,
                links: eedges
            });


            forceWorker.onmessage = function(event) {
                if (event.data.type === 'end') {
                    _context.beginPath();
                    _context.strokeStyle = "rgba(255, 34, 34, 0.35)";

                    for (let d of event.data.links) {
//                        _context.moveTo(d.source.x, d.source.y);
//                        _context.lineTo(d.target.x, d.target.y);

                        let n =  { "type": "Feature",
                                "geometry": {
                                    "type": "LineString",
                                    "coordinates": [[d.source.x, d.source.y], [d.target.x, d.target.y]]
                                },
                                "properties": {
                                }
                            };
                        path(n);

                    }

                    _context.stroke();
                }
            };
        }

        function bundleLinks() {
            bundlingWorker.terminate();
            bundlingWorker = new Worker('worker.js');

            bundlingWorker.postMessage({
                nodes: nnodes,
                links: eedges
            });

            bundlingWorker.onmessage = function(event) {
                if (event.data.type === 'end') {
                    _context.beginPath();
                    _context.lineWidth = 1;
                    _context.strokeStyle = "rgba(255, 34, 34, 0.35)";

                    for (let d of event.data.links) {
                        d3line(d);
                    }

                    _context.stroke();
                    _context.closePath();
                }
            };
        }

        function drawLinks() {
            forceLinks();
            bundleLinks();
        }


        function onMove() {
            // we update our calculated projections whenever the underlying map changes
            // due to zoom and pan
            vp = getVP();
            d3Projection = getD3();

            for (let nn in nnodes) {
                let p_ = [nnodes[nn].longitude, nnodes[nn].latitude];
                let Proj = mapboxProjection(p_);

                nnodes[nn].x  = Proj[0];
                nnodes[nn].y  = Proj[1];
            }

            drawPoints();

            _canvas.selectAll('.edge')
                .attr('opacity', 0);
        }

        // re-render our visualization whenever the view changes
        map.on("viewreset", function() {
            drawLinks()
        })
        map.on("dragend", function() {
            drawLinks()
        })
        map.on("pitchend", function() {
            drawLinks()
        })
        map.on("rotateend", function() {
            drawLinks()
        })
        map.on("zoomend", function() {
            drawLinks()
        })

        map.on('move', function(){
            onMove();
        });


    })
</script>

</body>
</html>
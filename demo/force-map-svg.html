<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=default"></script>
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="lib/crossfilter.js"></script>
    <script src="lib/chroma.js"></script>
    <script src="lib/viewport.js"></script>
    <script src="https://cdn.jsdelivr.net/lodash/4.17.4/lodash.min.js"></script>
    <script src="lib/d3-ForceEdgeBundling.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.38.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.38.0/mapbox-gl.css' rel='stylesheet' />
</head>
<body>

<style>
    #menu {
        position: absolute;
        background: #fff;
        padding: 10px;
        font-family: 'Open Sans', sans-serif;
    }

    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }
    #map {
        position:absolute;
        width: 100%;
        height: 100%;
    }
    svg {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    circle.mapbox {
        stroke: #7dde4f;
        fill: #7dde4f;
        fill-opacity: 0.9;
    }
    circle.vp {
        fill-opacity: 0.1;
        stroke: #111;
    }
    circle.d3 {
        fill-opacity: 0.1;
        stroke-width: 3;
        stroke: orange;
    }
</style>

<div id='map'></div>
<div id='menu'>
    <input id='basic' type='radio' name='rtoggle' value='basic' checked='checked'>
    <label for='basic'>basic</label>
    <input id='streets' type='radio' name='rtoggle' value='streets'>
    <label for='streets'>streets</label>
    <input id='bright' type='radio' name='rtoggle' value='bright'>
    <label for='bright'>bright</label>
    <input id='light' type='radio' name='rtoggle' value='light'>
    <label for='light'>light</label>
    <input id='dark' type='radio' name='rtoggle' value='dark'>
    <label for='dark'>dark</label>
    <input id='satellite' type='radio' name='rtoggle' value='satellite'>
    <label for='satellite'>satellite</label>
</div>

<script>
    $(function () {
        mapboxgl.accessToken = 'pk.eyJ1IjoiYmlnZmF0ZG9nIiwiYSI6ImM1ZWIyYzYzMzkyM2JlMTc0M2VjNmRlOTk5NDdkN2VjIn0.DoyA-reichUjF_FO9dkazQ';
        var map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/dark-v9',
            zoom: 4,
            pitch: 40,
            minZoom: 3,
            maxZoom: 18,
            center: [-74.0059, 40.7128],
        });

        var bundlingWorker = new Worker("worker.js");
        var forceWorker = new Worker("worker2.js");

        //map.scrollZoom.disable()
        map.addControl(new mapboxgl.NavigationControl());

        var layerList = document.getElementById('menu');
        var inputs = layerList.getElementsByTagName('input');

        function switchLayer(layer) {
            var layerId = layer.target.id;
            map.setStyle('mapbox://styles/mapbox/' + layerId + '-v9');
        }

        for (var i = 0; i < inputs.length; i++) {
            inputs[i].onclick = switchLayer;
        }
        // Setup our svg layer that we can manipulate with d3
        var container = map.getCanvasContainer();
        var svg = d3.select(container).append("svg")

        function asLine(d) {
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
        }

        // we can project a lonlat coordinate pair using mapbox's built in projection function
        function mapboxProjection(lonlat) {
            var p = map.project(new mapboxgl.LngLat(lonlat[0], lonlat[1]))
            return [p.x, p.y];
        }

        // we can use viewport-mercator-project to get projection and unprojection functions
        function getVP() {
            var bbox = document.body.getBoundingClientRect();
            var center = map.getCenter();
            var zoom = map.getZoom();
            var vp = ViewportMercator({
                longitude: center.lng,
                latitude: center.lat,
                zoom: zoom,
                width: bbox.width,
                height: bbox.height,
            })
            return vp;
        }


        // we calculate the scale given mapbox state (derived from viewport-mercator-project's code)
        // to define a d3 projection
        function getD3() {
            var bbox = document.body.getBoundingClientRect();
            var center = map.getCenter();
            var zoom = map.getZoom();
            // 512 is hardcoded tile size, might need to be 256 or changed to suit your map config
            var scale = (512) * 0.5 / PI * pow(2, zoom);

            var d3projection = d3.geoMercator()
                .center([center.lng, center.lat])
                .translate([bbox.width/2, bbox.height/2])
                .scale(scale);

            return d3projection;
        }


        // calculate the original viewport-mercator-project projection
        var vp = getVP();

        // calculate the original d3 projection
        var d3Projection = getD3()

        // we want to render the same point
        var point = [-74.0059, 40.7128]

        var mapboxCircle = svg.append("circle").classed("mapbox", true)
        var vpCircle = svg.append("circle").classed("vp", true)
        var d3Circle = svg.append("circle").classed("d3", true)

        // you can use any of these projections to create a d3.geo.path
        // function for rendering lines and polygons
        /*
         var path = d3.geo.path()
         .projection(mapboxProjection)
         */
        /*
         var path = d3.geo.path()
         .projection(d3Projection)
         */

        var points;
        var eedges = [];
        var nnodes = {};
        var _data = [];


        var d3line = d3.line()
            .x(function (d) {
                return d.x;
            })
            .y(function (d) {
                return d.y;
            })
            .curve(d3.curveCatmullRom.alpha(0.5));

        map.on('load', function() {

            d3.xml("assets/airlines.xml", function (xml) {
                //Transform the XML data into a proper format used by the algorithm
                var raw_edges = xml.documentElement.getElementsByTagName("edge");
                var raw_nodes = xml.documentElement.getElementsByTagName("node");


                for (var i = 0; i < raw_nodes.length; i++) {
                    var key = raw_nodes[i].getAttribute('id');

                    var name = raw_nodes[i].childNodes[3].firstChild.nodeValue;

                    var name2 = name.substring(name.indexOf('(') + 1, name.indexOf(')'));
                    let arr = name2.split(',')
                    let lon = arr[0].substring(5, name.length -1);
                    let lat = arr[1].substring(5, name.length -1);

                    let p_ = [lon, lat];
                    let proj = mapboxProjection(p_);
                    nnodes[key] = {
                        id: key,
                        latitude: lat,
                        longitude: lon,
                        x: proj[0],
                        y:  proj[1],
                    };
                }

                for (var i = 0; i < raw_edges.length; i++) {
                    eedges.push({
                        id: i,
                        'source': raw_edges[i].getAttribute('source'),
                        'target': raw_edges[i].getAttribute('target')
                    });
                }

                _data = _.values(nnodes);
                points = svg.selectAll('.mapbox')
                    .data(_data)
                    .enter()
                    .append('circle')
                    .attr('class', 'mapbox')
                    .attr('r', 3)
                    .attr('cx', function (d) {
                        return d.x;
                    })
                    .attr('cy', function (d) {
                        return d.y;
                    });


                forceWorker.postMessage({
                    nodes: nnodes,
                    links: eedges
                });

                bundlingWorker.postMessage({
                    nodes: nnodes,
                    links: eedges
                });

                forceWorker.onmessage = function(event) {
                    if (event.data.type === 'end') {
                        svg.selectAll('.edge')
                            .data(event.data.links)
                            .enter()

                            .append('path')
                            .attr("d", (d)=> {
                                return asLine(d) })
                            .attr('class', 'edge')
                            .style("stroke-width", 1)
                            .style("stroke", "#ff2222")
                            .style("fill", "none")
                            .style('stroke-opacity', 0.115);
                    }

                };

                bundlingWorker.onmessage = function(event) {
                    if (event.data.type === 'end') {
                        svg.selectAll('.edge')
                            .data(event.data.links)
                            .attr("d", (d)=> {
                                return d3line(d) })
                    }
                };

            });

        });

        function render() {

            forceWorker.terminate();
            bundlingWorker.terminate();

            forceWorker = new Worker('worker2.js');
            bundlingWorker = new Worker('worker.js');

            forceWorker.postMessage({
                nodes: nnodes,
                links: eedges
            });


            forceWorker.onmessage = function(event) {
                if (event.data.type === 'end') {
                    svg.selectAll('.edge')
                        .data(event.data.links)
                        .attr('opacity', 1)
                        .attr("d", (d)=> {
                            return asLine(d) });

                }
            };

            bundlingWorker.postMessage({
                nodes: nnodes,
                links: eedges
            });


            bundlingWorker.onmessage = function(event) {
                if (event.data.type === 'end') {
                    svg.selectAll('.edge')
                        .data(event.data.links)
                        .attr('opacity', 1)
                        .attr("d", (d)=> {
                            return d3line(d) });

                }
            };
        }

        function onMove() {
            // we update our calculated projections whenever the underlying map changes
            // due to zoom and pan
            vp = getVP();
            d3Projection = getD3();

            for (let nn in nnodes) {
                let p_ = [nnodes[nn].longitude, nnodes[nn].latitude];
                let Proj = mapboxProjection(p_);

                nnodes[nn].x  = Proj[0];
                nnodes[nn].y  = Proj[1];
            }

            _data = _.values(nnodes);

            svg.selectAll('.mapbox')
                .data(_data)
                .attr('cx', function (d) {
                    return d.x;
                })
                .attr('cy', function (d) {
                    return d.y;
                });

            svg.selectAll('.edge')
                .attr('opacity', 0);
        }

        // re-render our visualization whenever the view changes
        map.on("viewreset", function() {
            render()
        })
        map.on("dragend", function() {
            render()
        })
        map.on("pitchend", function() {
            render()
        })
        map.on("rotateend", function() {
            render()
        })
        map.on("zoomend", function() {
            render()
        })

        map.on('move', function(){
            onMove();
        });



        // render our initial visualization
//        render()

    })
</script>

</body>
</html>
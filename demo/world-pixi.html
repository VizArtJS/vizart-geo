<!DOCTYPE html>
<html style="height: 100%; margin: 0;">
<head>
    <title>Leaflet.PixiOverlay: 1000 US cities</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="css/carte.css"/>
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=default"></script>
    <script src='https://api.mapbox.com/mapbox.js/v3.1.1/mapbox.js'></script>
    <link href='https://api.mapbox.com/mapbox.js/v3.1.1/mapbox.css' rel='stylesheet' />
    <!--<link rel="stylesheet" href="leaflet/leaflet.css">-->
    <!--<script src="leaflet/leaflet.js"></script>-->

    <script src="lib/chroma.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script src="lib/lodash.min.js"></script>
    <script src="lib/d3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>
    <script src="leaflet/L.PixiOverlay.js"></script>
    <script src="lib/solveCollision.js"></script>
</head>
<body style="height: 100%; margin: 0; overflow: hidden;">
<div id="map" style="height: 100%; width: 100%;" class="cartes">
    <div class="legend geometry top center hide">
        <div class="wrapper">
            <div class="content"></div>
        </div>
    </div>
</div>
<script>

    var loader = new PIXI.loaders.Loader();
    loader
        .add('plane', 'img/plane.png')
        .add('focusPlane', 'img/focus-plane.png')
        .add('circle', 'img/circle.png')
        .add('focusCircle', 'img/focus-circle.png')
        .add('bicycle', 'img/bicycle.png')
        .add('focusBicycle', 'img/focus-bicycle.png');

    let nnodes = {};
    let eedges = [];


    let _color = d3.scaleOrdinal().range(
        [
            "#F44336",
            "#E91E63",
            "#9C27B0",
            "#673AB7",
            "#3F51B5",
            "#2196F3",
            "#03A9F4",
            "#00BCD4",
            "#009688",
            "#4CAF50",
            "#8BC34A",
            "#CDDC39",
            "#FFEB3B",
            "#FFC107",
            "#FF9800",
            "#FF5722"
        ]
    );

    document.addEventListener("DOMContentLoaded", function() {

        var map = L.map('map').setView([37.49229399862877, -96.94335937500001], 4);
        L.tileLayer(
            'https://api.mapbox.com/styles/v1/mapbox/traffic-night-v2/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiYmlnZmF0ZG9nIiwiYSI6ImM1ZWIyYzYzMzkyM2JlMTc0M2VjNmRlOTk5NDdkN2VjIn0.DoyA-reichUjF_FO9dkazQ',
            {
                minZoom: 2,
                maxZoom: 18,
                detectRetina: true,
            }).addTo(map);

        map.attributionControl.setPosition('bottomleft');
        map.zoomControl.setPosition('topright');
        var legend = document.querySelector('div.legend.geometry');
        var legendContent = legend.querySelector('.content');

        var bundlingWorker = new Worker("worker.js");

        var d3line = d3.line()
            .x(function (d) {
                return d.x;
            })
            .y(function (d) {
                return d.y;
            })
            .curve(d3.curveCatmullRom.alpha(0.5))

        loader.load(function(loader, resources) {
            var textures = [resources.circle.texture];
            var focusTextures = [resources.focusCircle.texture];

            d3.json("assets/leaflet/flights.json", function (data) {
                for (let i =0; i < data.airports.length; i++) {
                    let d = data.airports[i];
                    let lon =  d[3];
                    let lat = d[4];
                    if (lat === null || lon === null) {
                        console.log(d);
                    }
                    nnodes[i] = {
                        id: i,
                        airport: d[0],
                        city: d[1],
                        country: d[2],
                        longitude: lon,
                        latitude: lat || 0,
                    };
                }


                for (var i = 0; i < data.routes.length; i++) {
                    eedges.push({
                        id: i,
                        source: data.routes[i][1],
                        target: data.routes[i][2]
                    });
                }


                var pixiLayer = (function() {
                    var firstDraw = true;
                    var prevZoom;
                    var nodeSprites = [];
                    var linkSprites = [];
                    var colorScale = d3.scaleSequential(d3.interpolateViridis)
                        .domain([0, 50, 100])

                    var frame = null;
                    var focus = null;
                    var pixiContainer = new PIXI.Container();
                    return L.pixiOverlay(function(utils) {
                        var zoom = utils.getMap().getZoom();
                        if (frame) {
                            cancelAnimationFrame(frame);
                            frame = null;
                        }
                        var container = utils.getContainer();
                        var renderer = utils.getRenderer();
                        var project = utils.latLngToLayerPoint;
                        var scale = utils.getScale();
                        var invScale = 1 / scale;
                        if (firstDraw) {
                            prevZoom = zoom;
                            _.values(nnodes).forEach(function(marker) {
                                var coords = project([marker.latitude, marker.longitude]);
                                var index = Math.floor(Math.random() * textures.length);
                                var markerSprite = new PIXI.Sprite(textures[index]);
                                markerSprite.textureIndex = index;
                                markerSprite.x0 = coords.x;
                                markerSprite.y0 = coords.y;
                                markerSprite.anchor.set(0.5, 0.5);
                                let baseColor = d3.color(_color(marker.country));
                                var tint = baseColor.rgb();
                                markerSprite.tint = 256 * (tint.r * 256 + tint.g) + tint.b;
                                container.addChild(markerSprite);
                                nodeSprites.push(markerSprite);
                                markerSprite.legend = marker.id || marker.city || marker.label;

                                marker.x = coords.x;
                                marker.y = coords.y;
                            });


//                            let linkMap = {};
//
//                            for (let d of _color.domain()) {
//                                let linkGraphics =  new PIXI.Graphics();
//                                let _co = _.replace(chroma(_color(d.country)).hex(), '#', '0x');
//                                linkGraphics.beginFill();
//                                linkGraphics.lineStyle(2 / scale, _co, 0.2);
//                                linkGraphics.endFill();
//                                linkMap[d] = linkGraphics;
//                            }

                            let linkGraphics =  new PIXI.Graphics();

                            for (let e of eedges) {
                                let source = nnodes[e.source];
                                let target  = nnodes[e.target];

                                let _co = _.replace(chroma(_color(source.country)).hex(), '#', '0x');
                                linkGraphics.lineStyle(2 / scale, _co, 0.2);
                                linkGraphics.beginFill();
                                let sourceCoords = project([source.latitude, source.longitude]);
                                let targetCoords = project([target.latitude, target.longitude]);


                                linkGraphics.moveTo(sourceCoords.x, sourceCoords.y);
                                linkGraphics.lineTo(targetCoords.x, targetCoords.y);

                                linkGraphics.endFill();


                            }

                            container.addChild(linkGraphics);



                            var quadTrees = {};
                            for (var z = map.getMinZoom(); z <= map.getMaxZoom(); z++) {
                                var rInit = ((z <= 7) ? 16 : 24) / utils.getScale(z);
                                quadTrees[z] = solveCollision(nodeSprites, {r0: rInit, zoom: z});
                            }
                            function findMarker(ll) {
                                var layerPoint = project(ll);
                                var quadTree = quadTrees[utils.getMap().getZoom()];
                                var marker;
                                var rMax = quadTree.rMax;
                                var found = false;
                                quadTree.visit(function(quad, x1, y1, x2, y2) {
                                    if (!quad.length) {
                                        var dx = quad.data.x - layerPoint.x;
                                        var dy = quad.data.y - layerPoint.y;
                                        var r = quad.data.scale.x * 16;
                                        if (dx * dx + dy * dy <= r * r) {
                                            marker = quad.data;
                                            found = true;
                                        }
                                    }
                                    return found || x1 > layerPoint.x + rMax || x2 + rMax < layerPoint.x || y1 > layerPoint.y + rMax || y2 + rMax < layerPoint.y;
                                });
                                return marker;
                            }
                            map.on('click', function(e) {
                                var redraw = false;
                                if (focus) {
                                    focus.texture = textures[focus.textureIndex];
                                    focus = null;
                                    L.DomUtil.addClass(legend, 'hide');
                                    legendContent.innerHTML = '';
                                    redraw = true;
                                }
                                var marker = findMarker(e.latlng);
                                if (marker) {
                                    marker.texture = focusTextures[marker.textureIndex];
                                    focus = marker;
                                    legendContent.innerHTML = marker.legend;
                                    L.DomUtil.removeClass(legend, 'hide');
                                    redraw = true;
                                }
                                if (redraw) utils.getRenderer().render(container);
                            });
                            var self = this;
                            map.on('mousemove', L.Util.throttle(function(e) {
                                var marker = findMarker(e.latlng);
                                if (marker) {
                                    L.DomUtil.addClass(self._container, 'leaflet-interactive');
                                } else {
                                    L.DomUtil.removeClass(self._container, 'leaflet-interactive');
                                }
                            }, 32));
                        }
                        if (firstDraw || prevZoom !== zoom) {
                            nodeSprites.forEach(function(markerSprite) {
                                var position = markerSprite.cache[zoom];
                                if (firstDraw) {
                                    markerSprite.x = position.x;
                                    markerSprite.y = position.y;
                                    markerSprite.scale.set((position.r * scale < 16) ? position.r / 16 : invScale);
                                } else {
                                    markerSprite.currentX = markerSprite.x;
                                    markerSprite.currentY = markerSprite.y;
                                    markerSprite.targetX = position.x;
                                    markerSprite.targetY = position.y;
                                    markerSprite.currentScale = markerSprite.scale.x;
                                    markerSprite.targetScale = (position.r * scale < 16) ? position.r / 16 : invScale;
                                }
                            });
                        }

                        var start = null;
                        var delta = 250;
                        function animate(timestamp) {
                            var progress;
                            if (start === null) start = timestamp;
                            progress = timestamp - start;
                            var lambda = progress / delta;
                            if (lambda > 1) lambda = 1;
                            lambda = lambda * (0.4 + lambda * (2.2 + lambda * -1.6));
                            nodeSprites.forEach(function(markerSprite) {
                                markerSprite.x = markerSprite.currentX + lambda * (markerSprite.targetX - markerSprite.currentX);
                                markerSprite.y = markerSprite.currentY + lambda * (markerSprite.targetY - markerSprite.currentY);
                                markerSprite.scale.set(markerSprite.currentScale + lambda * (markerSprite.targetScale - markerSprite.currentScale));
                            });
                            renderer.render(container);
                            if (progress < delta) {
                                frame = requestAnimationFrame(animate);
                            }
                        }
                        if (!firstDraw && prevZoom !== zoom) {
                            frame = requestAnimationFrame(animate);
                        }
                        firstDraw = false;
                        prevZoom = zoom;
                        renderer.render(container);
                    }, pixiContainer, {
                        padding: 0.2,
                        doubleBuffering: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
                    });
                })();

                pixiLayer.addTo(map);
            });
        });
    });
</script>
</body>
</html>

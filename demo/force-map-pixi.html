<!DOCTYPE html>
<html style="height: 100%; margin: 0;">
<head>
    <title>Leaflet.PixiOverlay: 1000 US cities</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="css/carte.css"/>
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=default"></script>
    <script src='https://api.mapbox.com/mapbox.js/v3.1.1/mapbox.js'></script>
    <link href='https://api.mapbox.com/mapbox.js/v3.1.1/mapbox.css' rel='stylesheet' />
    <script src="https://unpkg.com/topojson@3"></script>
    <script src="lib/lodash.min.js"></script>
    <script src="lib/d3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>
    <script src="leaflet/L.PixiOverlay.js"></script>
    <script src="lib/solveCollision.js"></script>
</head>
<body style="height: 100%; margin: 0; overflow: hidden;">
<div id="map" style="height: 100%; width: 100%;" class="cartes">
    <div class="legend geometry top center hide">
        <div class="wrapper">
            <div class="content"></div>
        </div>
    </div>
</div>
<script>
    L.mapbox.accessToken = 'pk.eyJ1IjoiYmlnZmF0ZG9nIiwiYSI6ImM1ZWIyYzYzMzkyM2JlMTc0M2VjNmRlOTk5NDdkN2VjIn0.DoyA-reichUjF_FO9dkazQ';


    var loader = new PIXI.loaders.Loader();
    loader
        .add('plane', 'img/plane.png')
        .add('focusPlane', 'img/focus-plane.png')
        .add('circle', 'img/circle.png')
        .add('focusCircle', 'img/focus-circle.png')
        .add('bicycle', 'img/bicycle.png')
        .add('focusBicycle', 'img/focus-bicycle.png');

    let nnodes = {};
    let eedges = [];

    document.addEventListener("DOMContentLoaded", function() {

        var map = L.map('map').setView([37.49229399862877, -96.94335937500001], 4);
        L.tileLayer(
            'https://api.mapbox.com/styles/v1/mapbox/traffic-night-v2/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiYmlnZmF0ZG9nIiwiYSI6ImM1ZWIyYzYzMzkyM2JlMTc0M2VjNmRlOTk5NDdkN2VjIn0.DoyA-reichUjF_FO9dkazQ',
            {
                minZoom: 2,
                maxZoom: 18,
                detectRetina: true,
            }).addTo(map);

        map.attributionControl.setPosition('bottomleft');
        map.zoomControl.setPosition('topright');
        var legend = document.querySelector('div.legend.geometry');
        var legendContent = legend.querySelector('.content');

        var bundlingWorker = new Worker("worker.js");

        var d3line = d3.line()
            .x(function (d) {
                return d.x;
            })
            .y(function (d) {
                return d.y;
            })
            .curve(d3.curveCatmullRom.alpha(0.5))

        loader.load(function(loader, resources) {
            var textures = [resources.plane.texture];
            var focusTextures = [resources.focusPlane.texture];

            const planeTexture =

            d3.xml("assets/airlines.xml", function (xml) {
                //Transform the XML data into a proper format used by the algorithm
                var raw_edges = xml.documentElement.getElementsByTagName("edge");
                var raw_nodes = xml.documentElement.getElementsByTagName("node");


                for (var i = 0; i < raw_nodes.length; i++) {
                    var key = raw_nodes[i].getAttribute('id');

                    var name = raw_nodes[i].childNodes[3].firstChild.nodeValue;

                    var name2 = name.substring(name.indexOf('(') + 1, name.indexOf(')'));
                    let arr = name2.split(',')
                    let lon = arr[0].substring(5, name.length -1);
                    let lat = arr[1].substring(5, name.length -1);

                    nnodes[key] = {
                        id: key,
                        latitude: lat,
                        longitude: lon,
                    };
                }

                for (var i = 0; i < raw_edges.length; i++) {
                    eedges.push({
                        id: i,
                        source: raw_edges[i].getAttribute('source'),
                        target: raw_edges[i].getAttribute('target')
                    });
                }


                var pixiLayer = (function() {
                    var firstDraw = true;
                    var prevZoom;
                    var nodeSprites = [];
                    var linkSprites = [];
                    var colorScale = d3.scaleSequential(d3.interpolateViridis)
                        .domain([0, 50, 100])

                    var frame = null;
                    var focus = null;
                    var pixiContainer = new PIXI.Container();
                    return L.pixiOverlay(function(utils) {
                        var zoom = utils.getMap().getZoom();
                        if (frame) {
                            cancelAnimationFrame(frame);
                            frame = null;
                        }
                        var container = utils.getContainer();
                        var renderer = utils.getRenderer();
                        var project = utils.latLngToLayerPoint;
                        var scale = utils.getScale();
                        var invScale = 1 / scale;
                        if (firstDraw) {
                            prevZoom = zoom;
                            _.values(nnodes).forEach(function(marker) {
                                var coords = project([marker.latitude, marker.longitude]);
                                var index = Math.floor(Math.random() * textures.length);
                                var markerSprite = new PIXI.Sprite(textures[index]);
                                markerSprite.textureIndex = index;
                                markerSprite.x0 = coords.x;
                                markerSprite.y0 = coords.y;
                                markerSprite.anchor.set(0.5, 0.5);
                                var tint = d3.color(colorScale(marker.avancement || Math.random() * 100)).rgb();
                                markerSprite.tint = 256 * (tint.r * 256 + tint.g) + tint.b;
                                container.addChild(markerSprite);
                                nodeSprites.push(markerSprite);
                                markerSprite.legend = marker.id || marker.city || marker.label;

                                marker.x = coords.x;
                                marker.y = coords.y;
                            });

//                            d3line.context(renderer.context);
//
//                            console.log(renderer.context)


                            let linkGraphics =  new PIXI.Graphics();
                            linkGraphics.lineStyle(8, 0x3388ff, 0.3);
                            linkGraphics.beginFill(0x3388ff, 0.1);

                            for (let e of eedges) {
                                let source = nnodes[e.source];
                                let target  = nnodes[e.target];

                                let sourceCoords = project([source.latitude, source.longitude]);
                                let targetCoords = project([target.latitude, target.longitude]);

                                linkGraphics.moveTo(sourceCoords.x, sourceCoords.y);
                                linkGraphics.lineTo(targetCoords.x, targetCoords.y);

                            }

                            linkGraphics.endFill();
                            container.addChild(linkGraphics);

                            var quadTrees = {};
                            for (var z = map.getMinZoom(); z <= map.getMaxZoom(); z++) {
                                var rInit = ((z <= 7) ? 16 : 24) / utils.getScale(z);
                                quadTrees[z] = solveCollision(nodeSprites, {r0: rInit, zoom: z});
                            }
                            function findMarker(ll) {
                                var layerPoint = project(ll);
                                var quadTree = quadTrees[utils.getMap().getZoom()];
                                var marker;
                                var rMax = quadTree.rMax;
                                var found = false;
                                quadTree.visit(function(quad, x1, y1, x2, y2) {
                                    if (!quad.length) {
                                        var dx = quad.data.x - layerPoint.x;
                                        var dy = quad.data.y - layerPoint.y;
                                        var r = quad.data.scale.x * 16;
                                        if (dx * dx + dy * dy <= r * r) {
                                            marker = quad.data;
                                            found = true;
                                        }
                                    }
                                    return found || x1 > layerPoint.x + rMax || x2 + rMax < layerPoint.x || y1 > layerPoint.y + rMax || y2 + rMax < layerPoint.y;
                                });
                                return marker;
                            }
                            map.on('click', function(e) {
                                var redraw = false;
                                if (focus) {
                                    focus.texture = textures[focus.textureIndex];
                                    focus = null;
                                    L.DomUtil.addClass(legend, 'hide');
                                    legendContent.innerHTML = '';
                                    redraw = true;
                                }
                                var marker = findMarker(e.latlng);
                                if (marker) {
                                    marker.texture = focusTextures[marker.textureIndex];
                                    focus = marker;
                                    legendContent.innerHTML = marker.legend;
                                    L.DomUtil.removeClass(legend, 'hide');
                                    redraw = true;
                                }
                                if (redraw) utils.getRenderer().render(container);
                            });
                            var self = this;
                            map.on('mousemove', L.Util.throttle(function(e) {
                                var marker = findMarker(e.latlng);
                                if (marker) {
                                    L.DomUtil.addClass(self._container, 'leaflet-interactive');
                                } else {
                                    L.DomUtil.removeClass(self._container, 'leaflet-interactive');
                                }
                            }, 32));
                        }
                        if (firstDraw || prevZoom !== zoom) {
                            nodeSprites.forEach(function(markerSprite) {
                                var position = markerSprite.cache[zoom];
                                if (firstDraw) {
                                    markerSprite.x = position.x;
                                    markerSprite.y = position.y;
                                    markerSprite.scale.set((position.r * scale < 16) ? position.r / 16 : invScale);
                                } else {
                                    markerSprite.currentX = markerSprite.x;
                                    markerSprite.currentY = markerSprite.y;
                                    markerSprite.targetX = position.x;
                                    markerSprite.targetY = position.y;
                                    markerSprite.currentScale = markerSprite.scale.x;
                                    markerSprite.targetScale = (position.r * scale < 16) ? position.r / 16 : invScale;
                                }
                            });
                        }

                        var start = null;
                        var delta = 250;
                        function animate(timestamp) {
                            var progress;
                            if (start === null) start = timestamp;
                            progress = timestamp - start;
                            var lambda = progress / delta;
                            if (lambda > 1) lambda = 1;
                            lambda = lambda * (0.4 + lambda * (2.2 + lambda * -1.6));
                            nodeSprites.forEach(function(markerSprite) {
                                markerSprite.x = markerSprite.currentX + lambda * (markerSprite.targetX - markerSprite.currentX);
                                markerSprite.y = markerSprite.currentY + lambda * (markerSprite.targetY - markerSprite.currentY);
                                markerSprite.scale.set(markerSprite.currentScale + lambda * (markerSprite.targetScale - markerSprite.currentScale));
                            });
                            renderer.render(container);
                            if (progress < delta) {
                                frame = requestAnimationFrame(animate);
                            }
                        }
                        if (!firstDraw && prevZoom !== zoom) {
                            frame = requestAnimationFrame(animate);
                        }
                        firstDraw = false;
                        prevZoom = zoom;
                        renderer.render(container);
                    }, pixiContainer, {
                        padding: 0.2,
                        doubleBuffering: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
                    });
                })();

                pixiLayer.addTo(map);
            });
        });
    });
</script>
</body>
</html>
